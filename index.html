<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Green Fugitive</title>
    <style>
        :root {
            --background-color: #121212;
            --text-color: #E0E0E0;
            --accent-color: #4CAF50;
            --button-bg: #272727;
            --button-hover-bg: #383838;
            --font-main: 'Georgia', 'Times New Roman', serif;
            --font-ui: 'Helvetica Neue', 'Arial', sans-serif;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }

        #game-wrapper {
            max-width: 800px;
            width: 100%;
            border: 1px solid var(--button-bg);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #game-container {
            padding: 2em;
            background-color: rgba(0,0,0,0.2);
        }

        #story-text {
            line-height: 1.8;
            font-size: 1.1em;
            white-space: pre-wrap;
            margin-bottom: 2em;
            min-height: 200px;
        }

        #choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .choice-button {
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            padding: 15px;
            font-family: var(--font-main);
            font-size: 1em;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }

        .choice-button:hover {
            background-color: #333;
            transform: translateX(5px);
        }
        
        #ui-bar {
            background-color: var(--button-bg);
            padding: 10px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            border-top: 1px solid #444;
        }

        .ui-button {
            font-family: var(--font-ui);
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid #555;
            padding: 8px 15px;
            font-size: 0.9em;
            cursor: pointer;
        }

        .ui-button:hover {
            background-color: var(--button-hover-bg);
        }

        #loading-indicator {
            display: none;
            text-align: center;
            padding: 20px;
            color: var(--accent-color);
            font-style: italic;
        }

    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-container">
            <div id="story-text">Initializing...</div>
            <div id="choices"></div>
            <div id="loading-indicator">The threads of fate are weaving...</div>
        </div>
        <div id="ui-bar">
            <button id="save-button" class="ui-button">Save</button>
            <button id="load-button" class="ui-button">Load</button>
            <button id="restart-button" class="ui-button">Restart</button>
        </div>
    </div>

    <script type="module">
        // --- GAME STATE MANAGEMENT ---
        let gameState = {};

        const initialGameState = {
            character: {
                age: 0,
                gender: '',
            },
            location: 'START',
            secret: {
                type: "The Agricultural Method",
                role: "The Creator",
            },
            menaces: {
                despair: 0,
                paranoia: 0,
                exposure: 0,
            },
            worldState: {
                heat: 5, // The Authority's hunt is just beginning
                factionReputation: {
                    freeTowns: 0,
                    jackals: 0,
                },
            },
            storyFlags: {
                labDestroyed: false,
                hasEscaped: false,
            },
            inventory: ["Research Notes (Encrypted)"],
        };

        // --- CORE GAME SYSTEMS ---

        // The Hybrid Brain Model: Symbolic State Management
        function updateState(changes) {
            if (!changes) return;

            Object.keys(changes).forEach(key => {
                if (key in gameState) {
                    if (typeof gameState[key] === 'object' && gameState[key] !== null) {
                        // Handle nested objects like menaces, worldState
                        Object.assign(gameState[key], changes[key]);
                    } else {
                        gameState[key] = changes[key];
                    }
                }
            });
            autoSaveGame();
        }
        
        // --- SAVE/LOAD FUNCTIONALITY ---
        function saveGame() {
            try {
                localStorage.setItem('greenFugitiveSave', JSON.stringify(gameState));
                alert('Game Saved.');
            } catch (error) {
                console.error('Error saving game:', error);
                alert('Could not save game.');
            }
        }

        function autoSaveGame() {
             try {
                localStorage.setItem('greenFugitiveSave_auto', JSON.stringify(gameState));
            } catch (error) {
                console.error('Autosave failed:', error);
            }
        }

        function loadGame(isAuto = false) {
            try {
                const savedState = localStorage.getItem(isAuto ? 'greenFugitiveSave_auto' : 'greenFugitiveSave');
                if (savedState) {
                    gameState = JSON.parse(savedState);
                    if(!isAuto) alert('Game Loaded.');
                    renderScene();
                } else {
                    if(!isAuto) alert('No saved game found.');
                }
            } catch (error) {
                console.error('Error loading game:', error);
                alert('Could not load saved game. It may be corrupted.');
            }
        }
        
        function restartGame() {
            if (confirm("Are you sure you want to restart? Your progress will be lost.")) {
                localStorage.removeItem('greenFugitiveSave_auto');
                localStorage.removeItem('greenFugitiveSave');
                initializeGame();
            }
        }

        // --- NARRATIVE AND WORLD DATA ---
        const storyData = {
            'START': {
                isAIDriven: true,
                prompt: (startLocationText) => `
                    Persona: You are a tense, literary narrator for a survival horror game. Your style is evocative and grounded.
                    Task: Write the opening scene. The player is a scientist, The Creator of a secret agricultural method. Their lab is being raided by a militaristic group called The Authority. Describe the chaos of the final moments and their narrow escape.
                    Context: ${startLocationText} The player character is ${gameState.character.age} years old.
                    Format: A single, tense paragraph. End by stating the immediate escape route.
                `
            },
            // Add more scenes here as the story develops
        };
        
        const startLocations = [
            { id: 'UNIVERSITY_GREENHOUSE', text: "The lab was hidden in the derelict botanical wing of a city university. The escape is into a dense, urban jungle of crumbling skyscrapers." },
            { id: 'AQUIFER_BUNKER', text: "The lab was in a secret bunker built deep underground. The escape is upwards, to a vast, desolate wasteland under a brutal sun." },
            { id: 'COASTAL_RIG', text: "The lab was on a repurposed offshore platform. The escape is via a small boat, towards a fog-shrouded, swampy coastline." }
        ];

        // --- GEMINI API INTERACTION ---
        async function processPlayerAction(actionPrompt) {
            toggleLoading(true);

            // 1. Construct the context packet from the gameState
            const contextPacket = `
                ---
                Game State Context:
                Character: ${gameState.character.age}-year-old ${gameState.character.gender}.
                Location Details: Currently at ${gameState.location}.
                Hidden Menaces: Despair is at ${gameState.menaces.despair}/100. Paranoia is at ${gameState.menaces.paranoia}/100. Exposure is at ${gameState.menaces.exposure}/100.
                World State: The Authority's 'Heat' level is ${gameState.worldState.heat}/100.
                Inventory: ${gameState.inventory.join(', ')}.
                Key Flags: ${JSON.stringify(gameState.storyFlags)}.
                ---
            `;
            
            // Determine narrator's voice based on highest menace
            let persona = "You are a tense, literary narrator for a survival horror game. Your style is evocative and grounded.";
            const { despair, paranoia, exposure } = gameState.menaces;
            if (despair > 50 && despair >= paranoia && despair >= exposure) {
                persona = "You are a narrator colored by despair. Your prose is bleak, fatalistic, and focuses on decay and hopelessness.";
            } else if (paranoia > 50 && paranoia >= despair && paranoia >= exposure) {
                persona = "You are a narrator instilled with paranoia. Your prose is agitated, suspicious, focusing on shadows, potential threats, and untrustworthy details.";
            } else if (exposure > 50) {
                persona = "You are a narrator suffering from exposure. Your prose is fragmented, hazy, and focused on physical weakness and delirium.";
            }

            // 2. Construct the full prompt
            const fullPrompt = `
                Persona: ${persona}
                ${contextPacket}
                Task: The player has chosen to '${actionPrompt}'. Narrate the outcome of this action. Be descriptive and engaging. Then, based on the action and outcome, suggest changes to the game state.
                Format: Respond with a single, minified JSON object containing two keys: "narrativeText" (a string with the story) and "stateChanges" (an object with keys like "location", "menaces", "worldState", "storyFlags", "inventory", etc.). For menaces and heat, provide the new total value. For inventory, you can suggest "addItem" or "removeItem" with the item name as the value.
                Example stateChanges: {"menaces":{"despair":15},"worldState":{"heat":12},"storyFlags":{"foundKey":true},"inventory":{"addItem":"Water-purification-tablets"}}
            `;
            
            try {
                // 3. Call the secure proxy function
                const response = await fetch('/.netlify/functions/gemini-proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: fullPrompt })
                });

                if (!response.ok) {
                    throw new Error(`Serverless proxy error: ${response.statusText}`);
                }
                const data = await response.json();
               
                // Clean the response by removing markdown formatting
                const cleanedText = data.text.replace(/^```json\n|```$/g, '');
                
                // The text from Gemini is expected to be a JSON string.
                const aiResponse = JSON.parse(cleanedText);

                // 4. Process the response and update the game
                updateState(aiResponse.stateChanges);
                renderNarrative(aiResponse.narrativeText);
                
                // This is a placeholder for choices. A real implementation would have the AI suggest choices too.
                renderChoices([{ text: "Continue...", action: "Assess the situation." }]);

            } catch (error) {
                console.error("Error communicating with Gemini:", error);
                renderNarrative("A chilling sense of uncertainty grips you, as if the world itself is refusing to respond. (Error communicating with the game server. Check console for details.)");
                renderChoices([]);
            } finally {
                toggleLoading(false);
            }
        }
        
        function getInitialPrompt(sceneId, startLocation) {
            const scene = storyData[sceneId];
            if (scene.isAIDriven) {
                return scene.prompt(startLocation.text);
            }
            return "Describe the scene."; // Fallback
        }

        async function triggerInitialScene(startLocation) {
            toggleLoading(true);
            const initialPrompt = getInitialPrompt('START', startLocation);
            
             try {
                const response = await fetch('/.netlify/functions/gemini-proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: initialPrompt })
                });
                if (!response.ok) throw new Error(`Serverless proxy error: ${response.statusText}`);
                const data = await response.json();
                
                // For the initial scene, we only expect narrative text.
                renderNarrative(data.text);
                updateState({ location: startLocation.id, storyFlags: { labDestroyed: true } });
                renderChoices([{ text: "I have to get out of here. Now.", action: `Flee into the ${startLocation.id === 'COASTAL_RIG' ? 'swamp' : (startLocation.id === 'AQUIFER_BUNKER' ? 'wasteland' : 'urban jungle')}.` }]);

            } catch (error) {
                console.error("Error communicating with Gemini for initial scene:", error);
                renderNarrative("The world feels fuzzy, indistinct. Your memory of the escape is a blur. (Error generating initial scene.)");
            } finally {
                toggleLoading(false);
            }
        }


        // --- UI RENDERING ---
        const storyTextElement = document.getElementById('story-text');
        const choicesElement = document.getElementById('choices');
        const loadingIndicator = document.getElementById('loading-indicator');

        function renderNarrative(text) {
             // Typewriter effect for atmosphere
            let i = 0;
            storyTextElement.innerHTML = "";
            function typeWriter() {
                if (i < text.length) {
                    storyTextElement.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(typeWriter, 10); // Adjust typing speed here
                }
            }
            typeWriter();
        }

        function renderChoices(choices) {
            choicesElement.innerHTML = '';
            if (!choices) return;

            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-button';
                button.textContent = choice.text;
                button.onclick = () => {
                    // Here, we assume any choice triggers an AI response.
                    processPlayerAction(choice.action);
                };
                choicesElement.appendChild(button);
            });
        }
        
        function renderScene() {
            const scene = storyData[gameState.location];
            if (scene) {
                renderNarrative(scene.description);
                renderChoices(scene.choices);
            } else {
                // If the scene isn't statically defined, it must be AI-driven.
                // This would be the entry point for exploration.
                processPlayerAction("Look around the new area.");
            }
        }

        function toggleLoading(isLoading) {
            loadingIndicator.style.display = isLoading ? 'block' : 'none';
            choicesElement.style.display = isLoading ? 'none' : 'flex';
        }

        // --- GAME INITIALIZATION ---
        function initializeGame() {
            Object.assign(gameState, JSON.parse(JSON.stringify(initialGameState)));

            // Randomize character [user request]
            gameState.character.gender = Math.random() < 0.5 ? 'man' : 'woman';
            gameState.character.age = Math.floor(Math.random() * (75 - 35 + 1)) + 35; // Age 35-75

            // Randomize starting location [user request]
            const startLocation = startLocations[Math.floor(Math.random() * startLocations.length)];
            
            // Trigger the AI to write the opening scene
            triggerInitialScene(startLocation);
        }

        // --- EVENT LISTENERS ---
        document.getElementById('save-button').addEventListener('click', () => saveGame());
        document.getElementById('load-button').addEventListener('click', () => loadGame());
        document.getElementById('restart-button').addEventListener('click', () => restartGame());

        // --- START THE GAME ---
        // Check for an autosave first
        if (localStorage.getItem('greenFugitiveSave_auto')) {
             loadGame(true); // Load autosave silently
        } else {
            initializeGame();
        }
        
        /*
        ================================================================================
        == DEPLOYMENT AND SETUP INSTRUCTIONS ==
        ================================================================================

        To make this game fully functional, you need to securely connect to the Gemini API.
        
        **Step 1: Get your API Key**
        1. Go to Google AI Studio (https://aistudio.google.com/).
        2. Get your API key.

        **Step 2: Set up your Project**
        1. Create a new folder for your project.
        2. Save this file as "index.html" in that folder.
        3. Create a subfolder named "netlify". Inside "netlify", create another folder named "functions".
           (Your project structure should look like: /index.html, /netlify/functions/gemini-proxy.js)

        **Step 3: Create the Serverless Function**
        1. In the `netlify/functions` folder, create a file named `gemini-proxy.js`.
        2. Paste the following code into `gemini-proxy.js`:
        
        // --- start of gemini-proxy.js code ---
        import { GoogleGenerativeAI } from "@google/genai";

        export async function handler(event) {
            // Only allow POST requests
            if (event.httpMethod !== 'POST') {
                return { statusCode: 405, body: 'Method Not Allowed' };
            }

            try {
                // The API key is accessed from Netlify's environment variables
                const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
                const { prompt } = JSON.parse(event.body);
                
                if (!prompt) {
                     return { statusCode: 400, body: JSON.stringify({ error: "No prompt provided." }) };
                }

                const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const text = response.text();

                return {
                    statusCode: 200,
                    body: JSON.stringify({ text })
                };

            } catch (error) {
                console.error("Error in Netlify function:", error);
                return {
                    statusCode: 500,
                    body: JSON.stringify({ error: "Internal Server Error in proxy function." })
                };
            }
        }
        // --- end of gemini-proxy.js code ---
        
        **Step 4: Deploy to Netlify**
        1. Create a free account on Netlify (https://www.netlify.com/).
        2. Push your project folder to a GitHub, GitLab, or Bitbucket repository.
        3. In Netlify, select "New site from Git" and connect it to your repository.
        4. Netlify should detect your settings automatically. The publish directory is the root (`/`).
        5. Before deploying, go to your new site's settings: `Site settings > Build & deploy > Environment`.
        6. Add a new environment variable:
           - Key: `GEMINI_API_KEY`
           - Value: Paste your secret API key here.
        7. Deploy your site. Netlify will give you a public URL to your game.

        Your game is now live and securely using the Gemini API!
        */
    </script>
</body>
</html>
